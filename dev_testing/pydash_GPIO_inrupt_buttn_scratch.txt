#!/usr/bin/env python2.7  

# https://learn.sparkfun.com/tutorials/raspberry-gpio/python-rpigpio-api
# https://roboticsbackend.com/raspberry-pi-gpio-interrupts-tutorial/
# https://raspi.tv/how-to-use-interrupts-with-python-on-the-raspberry-pi-and-rpi-gpio-part-3  

"""
---------------------notes---------------------
    * Look at the tkinter "list box" widget for the menu display, errors, and CAN sniffer
        -has some convenient operators like "insert" and "delete" as well as "activate" and
         "selection_set" that can easily be used for modular control
         https://pythonassets.com/posts/listbox-in-tk-tkinter/
         https://www.geeksforgeeks.org/python-tkinter-listbox-widget/
         https://www.tutorialspoint.com/python/tk_listbox.htm
         
    * see hand notes for other ideas/comments on the menu layout. Start with getting a button
        to just open/close a new menu window and then be able to scroll up/down and then return
        to the main gauges window.
    
---------------------things to do---------------------
    1) make a simple "settings" menu
        a) will first have to make the "screen state" global struct for storing information
        b) use just 4 random options as first. Get into and out of menu (back to gauge display)
            as well as navigate up/down through the options
    2) add the PWM backlight control into the code
        a) just have it set to some initial value
    3) add the "backlight adjust" control into the code
        a) settings menu > backlight
        b) selecting will pop up a window with a numerical value + percent bar (slider)
            that will increase/decrease the PWM and screen brightness
    4) add the errors sub-menu
        a) will first have to make the "current errors" code. Involves a global array for
            errors and then a dict that contains the various errors when doing a "try" or
            some other error handling
        b) also add the "error" symbol to the bottom-center corner
    5) add the can-sniffer sub-menu
        a) first have to create the rx'd can struct (this can be local to the can sniffer window)
        b) listbox that shows the address and then rx'd value of the different packets
        c) real-time updates based on values recieved
"""

#----------------imports---------------------  
import RPi.GPIO as GPIO  
GPIO.setmode(GPIO.BCM)      #set GPIO to broadcom specific pin numbers

#----------------defines/constants---------------------  
"""
        button layout
        
        1   |               |   4
            |               |
        2   |    screen     |   5
            |               |
        3   |               |   6
"""
btn1 = 15
btn2 = 16
btn3 = 17
btn4 = 18
btn5 = 19
btn6 = 20

# !TODO: need to add a global struct for the current "screen state" and other settings like
#           backlight PWM, etc.

# !TODO: add a global dictionary to define the different screens


#----------------setup pins---------------------  
# PCB has external debounce and pullup, so no need to use "pullup" param
GPIO.setup(btn1, GPIO.IN)
GPIO.setup(btn2, GPIO.IN)
GPIO.setup(btn3, GPIO.IN)
GPIO.setup(btn4, GPIO.IN)
GPIO.setup(btn5, GPIO.IN)
GPIO.setup(btn6, GPIO.IN)  

#----------------function defines---------------------  
def callback_btn1_press(channel):
    match: scrn_info.state
        case scrn.main:
            #TODO: open menu (open/create settings window)
        case scrn.setngs:
            #TODO: go back to main menu
        case scrn.lvl_adj
            pass    # button does nothing when adjusting levels
        case scrn.err
            #TODO: go back to settings menu
        case scrn.CAN_snfr
            #TODO: go back to settings menu
        case default:
            #TODO: default case

def callback_btn2_press(channel):
    pass    # for now, button does nothing

def callback_btn3_press(channel):
    pass    # for now, button does nothing

def callback_btn4_press(channel):
    match: scrn_info.state
        case scrn.main:
            pass    # nothing on home screen
        case scrn.setngs:
            #TODO: select current highlight menu option
        case scrn.lvl_adj
            #TODO: set current level
        case scrn.err
            #TODO: delete error entry highlighted
        case scrn.CAN_snfr
            #TODO: reset/clear current CAN sniffer display
        case default:
            #TODO: default case

def callback_btn5_press(channel):
    match: scrn_info.state
        case scrn.main:
            pass    # TBD: main gauge screen up scroll to different displays
        case scrn.lvl_adj
            #TODO: increase value being adjusted
        case default:
            #TODO: highlight/navigate "up" to next item
            #           done for settings, error, and CANsniffer screens

def callback_btn6_press(channel):
    match: scrn_info.state
        case scrn.main:
            pass    # TBD: main gauge screen down scroll to different displays
        case scrn.lvl_adj
            #TODO: decrease value being adjusted
        case default:
            #TODO: highlight/navigate "down" to next item
            #           done for settings, error, and CANsniffer screens

#----------------attach interrupts---------------------  
# debounce time set to 100ms, should be ok with external debounce network but can adjust if needed
GPIO.add_event_detect(btn1, GPIO.FALLING, callback=callback_btn1_press, bouncetime=100)
GPIO.add_event_detect(btn2, GPIO.FALLING, callback=callback_btn2_press, bouncetime=100)
GPIO.add_event_detect(btn3, GPIO.FALLING, callback=callback_btn3_press, bouncetime=100)
GPIO.add_event_detect(btn4, GPIO.FALLING, callback=callback_btn4_press, bouncetime=100)
GPIO.add_event_detect(btn5, GPIO.FALLING, callback=callback_btn5_press, bouncetime=100)
GPIO.add_event_detect(btn6, GPIO.FALLING, callback=callback_btn6_press, bouncetime=100)
 
#----------------main part of script---------------------
# (already exists in code)

# GPIO cleanup to reset any GPIO back to their normal states. That way if
# anything is re-defined there's no conflict. IE, another script runs that
# has a different definition for a GPIO. May not need this on the 
# pydash script
GPIO.cleanup()           # clean up GPIO on normal exit  